%% This function implement the dynamical step of a fully actuated drone
% it takes the input generated by the controller and implements its 
% dynamic behaviour.
% drone.w, drone.s, drone.ds, drone.dds, drone.Ib, drone.theta, drone.phi, drone.m 



function out = classic_drone_system(vel_input, drone)
    
    T     = drone.T;
    dT    = drone.dT;
    s     = drone.s; 
    ds    = drone.ds; 
    dds   = drone.dds;
    ddds  = drone.ddds;


    theta = s(5);
    phi = s(4);
    psi = s(6);

    A = [ cos(psi)*sin(theta)*cos(phi)+sin(psi)*sin(phi), 0, 0, 0;
          sin(psi)*sin(theta)*cos(phi)-cos(psi)*sin(phi), 0, 0, 0;
                                     cos(phi)*cos(theta), 0, 0, 0;
                                                       0, 1, 0, 0;
                                                       0, 0, 1, 0;
                                                       0, 0, 0, 1];
    out = A*vel_input + [0;0;-9.81;0;0;0];
end


%% Auxiliary functions

function Rx=Rx(theta)
    Rx = [ 1,          0,          0;
           0, cos(theta),-sin(theta); 
           0, sin(theta), cos(theta)];
end
function Ry=Ry(theta)
    Ry = [ cos(theta), 0, sin(theta);
                    0, 1,          0;
          -sin(theta), 0, cos(theta)];
end

function Rz=Rz(theta)
    Rz = [ cos(theta), -sin(theta), 0;
           sin(theta),  cos(theta), 0;
                   0 ,           0, 1];
end

function S=Skew(p)
    S =[    0, -p(3),  p(2);
         p(3),     0, -p(1);
        -p(2),  p(1),    0];
end

function dS = Skew_dot(p)
    dt = [ 0,  0,  0;
           0,  0, -1;
           0,  1,  0;
           0,  0,  1;
           0,  0,  0;
          -1,  0,  0;
           0, -1,  0;
           1,  0,  0;
           0,  0,  0];
    dp= [p(1), p(1),p(1),p(2), p(2),p(2), p(3), p(3),p(3)   ;
         p(1), p(1),p(1),p(2), p(2),p(2), p(3), p(3),p(3)   ;
         p(1), p(1),p(1),p(2), p(2),p(2), p(3), p(3),p(3) ]';
    
    dS=-dt'*dp;
end

    